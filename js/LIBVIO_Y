const cheerio = createCheerio()

let appConfig = {
  ver: 20260201,
  title: 'LIBVIO',
  site: 'https://www.libvio.site',
  backupSites: [
    'https://www.libvio.fun',
    'https://www.libvio.me',
    'https://www.libvio.cc',
    'https://www.libvio.pro',
    'https://www.libvio.la',
  ],
  tabs: [
    { id: '20', name: '电影', ext: { type: '20' } },
    { id: '21', name: '电视剧', ext: { type: '21' } },
    { id: '22', name: '综艺', ext: { type: '22' } },
    { id: '23', name: '动漫', ext: { type: '23' } },
    { id: '24', name: '纪录片', ext: { type: '24' } },
  ],
}

let currentSite = appConfig.site

async function getConfig() {
  return jsonify(appConfig)
}

async function getCards(ext) {
  ext = argsify(ext)
  let cards = []
  let { type, page = 1 } = ext

  try {
    const url = `${currentSite}/type/${type}-${page}.html`
    const headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
      'Referer': currentSite,
    }

    const { data } = await $fetch.get(url, { headers })
    const $ = cheerio.load(data)
    const addedIds = new Set()

    $('.stui-vodlist__box').each((i, el) => {
      const $el = $(el)
      const $link = $el.find('a.stui-vodlist__thumb').first()
      const href = $link.attr('href')
      
      if (!href) return
      
      const idMatch = href.match(/\/detail\/(\d+)\.html/)
      if (!idMatch) return
      
      const id = idMatch[1]
      if (addedIds.has(id)) return
      addedIds.add(id)

      const title = $link.attr('title') || $el.find('.title').text().trim()
      const pic = $link.attr('data-original') || $el.find('img').attr('data-original') || $el.find('img').attr('src')
      const remarks = $el.find('.pic-text').text().trim()

      if (title) {
        cards.push({
          vod_id: id,
          vod_name: title,
          vod_pic: pic || '',
          vod_remarks: remarks || '',
          vod_duration: '',
          ext: {
            id: id,
            type: type,
          },
        })
      }
    })

    return jsonify({ list: cards })
  } catch (error) {
    if (await tryBackupSite()) {
      return await getCards(ext)
    }
    return jsonify({ list: [] })
  }
}

async function getTracks(ext) {
  ext = argsify(ext)
  let allTracks = []
  let { id, type } = ext

  try {
    const url = `${currentSite}/detail/${id}.html`
    const headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
      'Referer': currentSite,
    }

    const { data } = await $fetch.get(url, { headers })
    const $ = cheerio.load(data)

    $('.stui-content__playlist').each((playlistIndex, playlistEl) => {
      const $playlist = $(playlistEl)
      const playlistTitle = $playlist.prev('h3').text().trim() || 
                           $playlist.prev('.title').text().trim() || 
                           `播放列表${playlistIndex + 1}`
      const tracks = []

      $playlist.find('li a').each((i, el) => {
        const $el = $(el)
        const name = $el.text().trim()
        const href = $el.attr('href')

        if (name && href) {
          tracks.push({
            name: name,
            pan: '',
            ext: {
              videoId: id,
              playUrl: href,
              episodeIndex: i,
              playlistIndex: playlistIndex,
            },
          })
        }
      })

      if (tracks.length > 0) {
        allTracks.push({
          title: playlistTitle,
          tracks: tracks,
        })
      }
    })

    return jsonify({ list: allTracks })
  } catch (error) {
    if (await tryBackupSite()) {
      return await getTracks(ext)
    }
    return jsonify({ list: [] })
  }
}

async function getPlayinfo(ext) {
  ext = argsify(ext)
  let { videoId, playUrl } = ext

  try {
    const url = playUrl.startsWith('http') ? playUrl : `${currentSite}${playUrl}`
    const headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
      'Referer': `${currentSite}/detail/${videoId}.html`,
    }

    const { data } = await $fetch.get(url, { headers })
    let realPlayUrl = ''

    // 方式1: 匹配 player_aaaa 配置对象中的 url
    let match = data.match(/player_[a-z]+\s*=\s*\{[^}]*"url"\s*:\s*"([^"]+)"/i)
    if (match) {
      realPlayUrl = match[1]
    }

    // 方式2: 匹配 MacCmsPlayer 配置
    if (!realPlayUrl) {
      match = data.match(/MacPlayer\s*\.\s*Parse\s*\([^)]*url\s*:\s*["']([^"']+)["']/i)
      if (match) {
        realPlayUrl = match[1]
      }
    }

    // 方式3: 匹配 var now 或类似变量中的 URL
    if (!realPlayUrl) {
      match = data.match(/var\s+\w+\s*=\s*["']([^"']*(?:\.m3u8|\.mp4)[^"']*)["']/i)
      if (match) {
        realPlayUrl = match[1]
      }
    }

    // 方式4: 直接匹配完整的 .mp4 URL（针对你的实际请求）
    if (!realPlayUrl) {
      match = data.match(/(https?:\/\/[^\s"'<>]+\.mp4(?:\?[^\s"'<>]*)?)/i)
      if (match) {
        realPlayUrl = match[1]
      }
    }

    // 方式5: 直接匹配 .m3u8 链接
    if (!realPlayUrl) {
      match = data.match(/(https?:\/\/[^\s"'<>]+\.m3u8(?:\?[^\s"'<>]*)?)/i)
      if (match) {
        realPlayUrl = match[1]
      }
    }

    // 方式6: 匹配 JSON 格式的 url 字段
    if (!realPlayUrl) {
      match = data.match(/["']url["']\s*:\s*["']([^"']+)["']/i)
      if (match) {
        realPlayUrl = match[1]
      }
    }

    // 方式7: 检查 iframe 嵌套播放器
    if (!realPlayUrl) {
      const $ = cheerio.load(data)
      const iframeSrc = $('iframe').attr('src')
      
      if (iframeSrc) {
        // 如果 iframe 直接包含视频链接
        if (iframeSrc.includes('.m3u8') || iframeSrc.includes('.mp4')) {
          realPlayUrl = iframeSrc
        } 
        // 如果是第三方播放器，尝试请求它
        else if (iframeSrc.startsWith('http')) {
          try {
            const iframeUrl = iframeSrc.startsWith('//') ? 'https:' + iframeSrc : iframeSrc
            const iframeHeaders = {
              'User-Agent': headers['User-Agent'],
              'Referer': url,
            }
            const iframeData = await $fetch.get(iframeUrl, { 
              headers: iframeHeaders,
              timeout: 10000 
            })
            
            // 在 iframe 内容中查找视频链接
            const iframeMatch = iframeData.data.match(/(https?:\/\/[^\s"'<>]+\.(?:m3u8|mp4)(?:\?[^\s"'<>]*)?)/)
            if (iframeMatch) {
              realPlayUrl = iframeMatch[1]
            }
          } catch (e) {
            // iframe 请求失败，继续其他方法
          }
        }
      }
    }

    // 方式8: 查找 script 标签中的加密或编码 URL
    if (!realPlayUrl) {
      const $ = cheerio.load(data)
      $('script').each((i, el) => {
        const scriptContent = $(el).html()
        if (scriptContent) {
          // 匹配可能的视频 URL
          const urlMatch = scriptContent.match(/(https?:\/\/[^\s"'<>]+\.(?:m3u8|mp4)(?:\?[^\s"'<>]*)?)/)
          if (urlMatch) {
            realPlayUrl = urlMatch[1]
            return false // 跳出循环
          }
        }
      })
    }

    if (realPlayUrl) {
      // 清理和标准化 URL
      realPlayUrl = realPlayUrl.replace(/\\/g, '').trim()

      // 处理相对路径
      if (!realPlayUrl.startsWith('http')) {
        if (realPlayUrl.startsWith('//')) {
          realPlayUrl = 'https:' + realPlayUrl
        } else if (realPlayUrl.startsWith('/')) {
          const siteUrl = new URL(currentSite)
          realPlayUrl = siteUrl.origin + realPlayUrl
        }
      }

      // 解码可能的 URL 编码
      try {
        if (realPlayUrl.includes('%')) {
          realPlayUrl = decodeURIComponent(realPlayUrl)
        }
      } catch (e) {
        // 解码失败，使用原始 URL
      }

      // 返回播放信息，添加必要的 headers
      return jsonify({ 
        urls: [realPlayUrl],
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
          'Referer': currentSite,
          'Accept': '*/*',
          'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
        }
      })
    }

    return jsonify({ urls: [] })
  } catch (error) {
    return jsonify({ urls: [] })
  }
}

async function search(ext) {
  ext = argsify(ext)
  let cards = []
  const keyword = ext.text
  const page = ext.page || 1

  try {
    const url = `${currentSite}/search/${encodeURIComponent(keyword)}----------${page}---.html`
    const headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
      'Referer': currentSite,
    }

    const { data } = await $fetch.get(url, { headers })
    const $ = cheerio.load(data)
    const addedIds = new Set()

    $('.stui-vodlist__box').each((i, el) => {
      const $el = $(el)
      const $link = $el.find('a.stui-vodlist__thumb').first()
      const href = $link.attr('href')
      
      if (!href) return
      
      const idMatch = href.match(/\/detail\/(\d+)\.html/)
      if (!idMatch) return
      
      const id = idMatch[1]
      if (addedIds.has(id)) return
      addedIds.add(id)

      const title = $link.attr('title') || $el.find('.title').text().trim()
      const pic = $link.attr('data-original') || $el.find('img').attr('data-original') || $el.find('img').attr('src')
      const remarks = $el.find('.pic-text').text().trim()

      if (title) {
        cards.push({
          vod_id: id,
          vod_name: title,
          vod_pic: pic || '',
          vod_remarks: remarks || '',
          vod_duration: '',
          ext: {
            id: id,
            type: '20',
          },
        })
      }
    })

    return jsonify({ list: cards })
  } catch (error) {
    if (await tryBackupSite()) {
      return await search(ext)
    }
    return jsonify({ list: [] })
  }
}

async function tryBackupSite() {
  for (const site of appConfig.backupSites) {
    if (site !== currentSite) {
      try {
        const { data } = await $fetch.get(`${site}/type/20-1.html`, {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          },
          timeout: 5000,
        })
        if (data) {
          currentSite = site
          return true
        }
      } catch (e) {
        continue
      }
    }
  }
  return false
}
